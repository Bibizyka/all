#include<iostream>
#include<conio.h>
#include<stack>
using namespace std;
typedef pair <int,int> Pair;// Тип пары для считывание "родитель-потомок" из входного файла.

/*
*	УСЛОВИЕ ЗАДАЧИ: В текстовом файле задана информация о произвольном дереве. Первая строка - количество элементов,
* остальные строки - попарно заданы родительский элемент и потомок. В результате можно вбить произвольное дерево.
*   НУЖНО ВЫВЕСТИ: бинарное дерево, созданное из произвольного заданного дерева. Одноуровневые элементы необходимо
* последовательно в глубину дерева соединить(друг за другом).
*	Вывожу не в файл output.txt, а в консоль. Быстрее работает.
*
*	Решение:
Известно, что дерево c n>2 ветками на одном уровне строить не нужно. Оно нам задаётся в текстовом формате.
* 1) Если проанализировать входной файл, то ясно, что первый/главный корень дерева во втором столбце статистически никогда
* не повторится! Следует - его нужно найти из столбца родителей не повторяемостью в столбце потомков.
* 2) Создаём стек для хранения адресов. В этот стек заносим все адреса, всех деревьев, которые сможем создать. 
* Например, у нас есть входной файл:
* 5
* 1 2
* 2 3
* 2 4
* 1 6
* 4 9
* Все возможные деревья: 1-2-6, 2-3-4, 4-9. Во входном файле их может быть тысячи вариантов. Задача решабельна быстро.
* 3) Этап третий: найти корневой элемент в стеке. Сделать его главным корнем! Затем к этому главное корню присоединяются остальные элементы, которые
* находятся в стеке по значению своего подглавного корня. Используется рекурсивная функция поиска места для ветки-взятой из стека и обыкновенный функция 
* добавления ветки к найденном месту.
*/

//Двоичное дерево. Структура.
struct Node
{
	int info;
	Node *left, *right;
	Node (int x)
	{
		info=x; left=NULL; right=NULL;
	}
};

//Печать двоичного дерева. Рекурсия
void PrintR(Node *r)
{
	if (r==NULL) return;
	else 
	{
		cout<<r->info<<" ";
		PrintR(r->left);
		PrintR(r->right);
	}
}
//ПОИСК корневого поддерева. В дальнейшем используется вообще для ПОИСКА веток-деревьев, занесённых в стек.
Node* Koren(stack <Node*> q,int kor)
{
	Node *p;
	L1:
	if (q.empty()==false)
	{
		p=q.top();
		if (p->info==kor)
		return p;
		else
		{
			q.pop();
			goto L1;
		}
	}
	;
	return p;
}

//Рекурсивная функция ДОБАВЛЕНИЯ найденного поддерева-корня в главное дерево.
void addInRoot(stack <Node*> tree, Node*root, int x)
{
	if (root!=NULL && root->info!=x)
	{
		addInRoot(tree, root->left, x);
		addInRoot(tree, root->right, x);
	}
	else
	{
		if (root!=NULL && root->info==x)
			root->right=Koren(tree,x)->left;
		else return;
	}
}

void BinaryTreeFromDifferentlyTree(Node* &root)
{
		int const N=100;
	Pair a[N];
	int kol;
	freopen("input.txt","r",stdin);//Выводим в консоль.
	//freopen("output.txt","w",stdout);

	cin>>kol;//Считываем из входного файла количество пар.
	cout<<kol<<endl;
	for(int i=0;i<kol; i++)//Cчитываем пары из заданного входного файла.
	{
		cin>>a[i].first; cin>>a[i].second;
	}
	for(int i=0;i<kol; i++)
	{
		cout<<a[i].first<<"_"<<a[i].second<<endl;
	}
	//Найдем корень.
	//Найдём корневой элемент.
	/*Известно при анализе таблицы, что корневой элемент не является потомком какого-либо! Значит - он не должен повториться во втором
	столбце.
	*/
	int koren;
	for (int i=0; i<kol; i++)
	{
		koren=0;
		for (int j=0; j<kol; j++)
		{
			if (a[i].first==a[j].second) koren++;
		}
		if (koren==0) {koren=a[i].first; break;}//Главный корень(значение по которому его потом уже найду) найден! Значит - break, прекращаем работу.
	}
	
	//Сначала создадим "кучу" всех возможных деревьев(как я привел в примере).
	stack <Node*>tree;
	int kolTrees=0, b, and[N];//Считаем количество поддеревьев.
	for(int i=0;i<kol;i++)
	{
		if (a[i].first!=N)
		{
			and[kolTrees]=a[i].first;//Заполняем массив значениями первых ->info у веток-поддеревьев.
			Node* inTree=new Node(a[i].first);
			Node* prov=inTree;//Создаём копию адреса новой формируемой ветки. Т.к. оригинал будет испорчен.
			tree.push(prov);//

			inTree->left=new Node(a[i].second);
				inTree=inTree->left;
			b=a[i].first;
			a[i].first=N;
			for(int j=i+1; j<kol; j++)
			{
				if (a[j].first==b)
				{

					inTree->left=new Node(a[j].second);//Процесс создания ветки=поддерева.
						inTree=inTree->left;
					a[j].first=N;
				}
			}
			/*cout<<"A1)"; PrintR(prov); cout<<"A2)"; PrintR(inTree);//Использовались для теста-проверки правильной работы частей программы. Вывод некоторых результатов.
			Node *z=tree.top();cout<<"AB)"; PrintR(z);cout<<endl;
			*/
			kolTrees++;//Считаем количество вообще всех созданных веток.
		//	tree.push(inTree); tree2.push(inTree);;//Использовались для проверки правильной работы частей программы.
		}
	}
	
	//Собственно, начинаем строить дерево.
	root=Koren(tree, koren);//Нашли главный корень из стека поддеревьев ПО ЕГО ПЕРВОГО ЗНАЧЕНИЮ(->info)
	/*PrintR(root); cout<<endl;*/  //Использовались для проверки правильной работы частей программы.
 	//Удаляем корневой элемент из массива значений корней.(Не из стека!)
	for(int i=0; i<kolTrees; i++)
	{
		if (and[i]==koren)
		{
			int b=and[kolTrees-1];
			and[kolTrees-1]=and[i];
			and[i]=b;
			kolTrees--;
			break;
		}
	}
	for(int i=0; i<kolTrees; i++)
		//Собственно основная часть программы. 
		//Идет поиск веток, их добавление в основное дерево, затем новый поиск, новое добавление...Пока ветки не закончатся.
	{
		addInRoot(tree, root, and[i]);
	}

}

int main()
{
	Node* root;
	BinaryTreeFromDifferentlyTree(root);//Основная функция, реализующая действие задачи.
	PrintR(root);//Печатаем полученное дерево.

	//"Хвосты" в виде заполненных стеков-деревьев-массивов не подчищаем, ибо программа маленькая + конец работы все программы. 
	//Данные удалятся в конце работы программы.
	getch();
	return 0;
}