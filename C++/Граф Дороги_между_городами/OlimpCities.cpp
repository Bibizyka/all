#include<iostream>

//#define __RRR__
/*
*	УСЛОВИЕ ЗАДАЧИ:
*		Даны города - вершины графа с определённым весом рёбер - стоимостью проезда.
*		Выбрать наиболее дешевую цену проезда из города А в город Б, при этом "дешевизна" складывается из минимальной цены от всех максимальных цен на отрезках-дорогах,
*	по которым можно проихать в города.
*
*	Решено не гениально, элементарным BFS с перебором и выбором.
*
*
*
*
*/
using namespace std;

class Graph
{
private:
	int n;
	int **e;//Массив ребёр. И веса связей тоже.
	int minPrice;//Будет время и желание - постараться вывести эти 5 переменных вне класса графа.
	int maxInWay;
	int *minimCena;
	int schet;
	bool ok;
public:
	Graph();
	Graph(int);
	Graph(int, int**);
	Graph(Graph&);
	void addEdge(int i, int j, int g);
	void printMatrica();
	void clearMatrica();//Обнуляем матрицу для нового графа.
	void Roads(int a);
	void RecSearch(int i, int j, bool visited[], int maxInWay);
};
void Graph::clearMatrica()
{
	for(int i=0; i<n; i++)
		/*for(int j=0; j<n; j++)
			e[i][j]=0;*/
			delete e[i];

}

void Graph::Roads(int a)
{
	int b=0;
	//int a=0, b=a+1
	//Можно устроить перебор вершин(цикл), которые можно посетить..вообще. Но это нам не нужно.
	//for(;a<n-1;a++){
	while(b<n)
	{
		if (a==b) 
		{
			cout<</*"From "<<a<<" to "<<b<<" = "<<*/0<<endl; b++;
		}
		else
		{
			//Проведём поиск легких весов-дешевых путей и их печать(если возможно)
			//a!=b (!!!) По условию.
			bool *visited=new bool[n];//Не забыть удалить динам.массив проверки ходом.
			minimCena=new int[n];//Динамический массив проверки минимальной цены.
			for(int i=0; i<n; i++)//Создадим подмассив для проверок ходов(антицикл).
			{
				visited[i]=false;
				minimCena[i]=20001;//Одновременно заполним массив цен.
			}
			visited[a]=true;
				
			//Эти переменные объявлены глобальное в классе Graph.
			minPrice=20001;//Минимальная цена. Но принимается как возможны "потолок" стоимостей.
			maxInWay=0;	//Максимальная стоимость на определённом пути.
			ok=false;//Проверка - а есть ли вообще пути? Если нет - печатаем "Impossible".
			schet=0;//Глобальный счётчик для глобального массива minimCena

			RecSearch(a,b,visited,maxInWay);//Нашли a & b, запускаем рекурсию.
			//Рекурсию отработала. Найдем минимальную цену в массиве максимально "дорогих" отрезков на N-путях!
			for(int i=0; i<n; i++)
			{
				if (minimCena[i]<minPrice)
					minPrice=minimCena[i];
			}
			//Соответственно - печатаем возможность пути.
			if (ok) cout<</*"From "<<a<<" to "<<b<<" = "<<*/minPrice<<endl; else cout<</*a<<" to "<<b<<*/"Impossible"<<endl;
			delete []visited;//Удаляем массив посещений
			b++;
		}
	}
//}
}

//Рекурсивная функция поиска места для элемента. Обход графа.
void Graph::RecSearch(int a, int b, bool visited[], int maxInWay)
{
	for(int i=0; i<n; i++)//Перебираем соседние вершины.
	{
		if (e[a][i]!=0 && visited[i]==false)//Нашли соседнюю точку. 
		{	
			bool visitedC[10]; int t=maxInWay;//Создаём элементы, которые существуют лишь в данной "временной рекурсии".
			//Они и передаются последующим рекурсиям, вызванным данной. В результате не происходит смешение предметов поиска.
			for(int q=0; q<n; q++)//Заполняем временной масив для заданной рекурсии - проверка посещения вершины.
			{//Её мы в дальнейшем и передаём.
				visitedC[q]=visited[q];
			}
			visitedC[i]=true;//Помечаем как помещенную.
			{
				if (e[a][i]>t) t=e[a][i];//Ищем максимальную стоимость для данного N-возможного пути. Как следствие - N максимальных стоимостей,
				//из которых в дальнейшем и выбирается наиболее оптимальный.
			}
			{
			if (i==b) 
				{
					ok=true; minimCena[schet++]=t; return;
					//Нашли вершину - значит OK(это значит, что вообще есть что печатать)
					//Заносим в массив minimCena максимальную стоимость для данного n-го пути. Затем в функции Roads нужно будет только выбрать минимальный из N максимальных стоимостей.
					//Для маленького массива N всегда не более 3-4.
				}
			else RecSearch(i,b, visitedC, t);//Если же вершину не нашли - запускаем новую рекурсию и ищем дальше....
			}	
		}

	}
	return;
	/*
		Вызываем рекурсию и передаем ей начальный элемент и конечный с массивом состояний. В каждой рекурсии собственный массив состояний.
		Затем в функции ищем соединения с другими вершинами. Даже если вершины совпали - запускаем рекурсию, пока НЕ будет найдена конечная
	для всех рекурсий вершина.
		Нам нужно найти сначала max цену на всем пути. А затем, если она меньше установленной(minPrice) - присвоить установленной maxInWay.
		И печать наиболее благоприятного результата.


	*/
}

Graph::Graph(int n)
{
	//Создаём матрицу графа.
	this->n=n;
	e=new int*[n];
	for(int i=0; i<n; i++)
	{
		e[i]=new int[n];
		for(int j=0; j<n; j++)
			e[i][j]=0;
	}
};

void Graph::addEdge(int i, int j, int g)
{
	if (e[i][j]==0)	
	{
		e[i][j]=g;
		e[j][i]=g;
	};
	if (e[i][j]>g && e[j][i]>g)
	{
		e[i][j]=g;
		e[j][i]=g;
	}
}

int main()
{
	#ifdef __RRR__
	freopen("Sample Input.txt","r",stdin);//Выводим в консоль.
	freopen("Output for Sample Input.txt","w",stdout);
	#endif

	int cicle, kolVershin, kolReber, i, j, pusto;

	cin>>cicle;// Количество циклов.
	for(int s=0; s<cicle; s++)//Обрабатываем входной файл.
	{
		cin>>kolVershin; cin>>kolReber;
		Graph gr(kolVershin);
			//Добавим в граф данные. Граф НЕориентированный!
		cout<<"Case "<<s+1<<":"<<endl;
		for(int q=0; q<kolReber; q++)
		{
			cin>>i; cin>>j; cin>>pusto;
			gr.addEdge(i,j,pusto);//Формируем НЕориентированный граф по условию задачи. 
		//Добавляем в него самые дешевые номера.
		}
		cin>>pusto;
		//Вызовем функцию проверки стоимости проездов.
		gr.Roads(pusto);
		gr.clearMatrica();
		//cout<<endl;
	}

	return 0;
}