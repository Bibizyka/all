#include<conio.h>
#include<iostream>
#include <fstream>

using  namespace std;

int n = 0;// Размерность матрицы смежности - количество точек-вершин графа
int m = 0;// Количество переходов(ребра графа)
int const N = 100;// Размер матрицы максимальный
int MASS[N][N];// Матрица смежности

// Возвращает позицию элемента в массиве
int Position(int nomer, int*vershini)
{
	for (int i = 0; i < n; i++)
	{
		if (vershini[i] == nomer)
			return i;
	}
	// Если элемент не нашелся - вернёт -1
	return -1;
}

// Печать тех путей, на которых мы побывали
void Print(int * vershini, int sum, int nomer_ish)
{
	// Мы получили неупорядоченный массив вершин, которые посетили
	// Теперь нужно показать как они идут по порядку посещения
	
	for (int i = 0; i < n; i++)
	{
		int p = Position(i, vershini);// Вернёт позицию, где элемент = i. Эта позиция и будет вершиной, которую посетили по порядку
		if (p != -1)
			cout << p<<"-";
	}
	cout << nomer_ish << "-";// Печатаем исходную вершину(её номер)
	cout <<  "цикл закончился, длина пути = " << sum << endl;
	cout << endl;
}

void Recursion(int nomer_ish, int nomer, int kol, int sum,  int *vershini)
{
	// Перейдя на новую вершину
	vershini[nomer] = kol;
	kol = kol + 1;

	// Теперь будем идти по строке матрицы смежности для заданной вершины: ищем вершины, в которых ещё не отметились переходом
	for (int j = 0; j < n; j++)
	{
		// Если существует переход на вершину, то проверим - не вернемся ли мы на исходную?
		if (MASS[nomer][j] > 0)
		{
			// Если вернемся на исходную - то всё ок, напечатаем последнюю вершину и сумму длин
			if (j == nomer_ish)
			{
				if (kol > 1)
				{
					// Отмечаем вершину как посещенную и печатаем результат
					Print(vershini, sum + MASS[nomer][j], nomer_ish);
					continue;
				}
				else
				{
					continue;
				}
			}
			// Если же нет - то переходим на новую вершину, отмечая в массиве вершин старую вершину как пройденную
			else
			{
				// Если в этой вершине мы ещё не были - делаем переход на неё:
				if (vershini[j] == -1)
				{
					// Новый массив вершин(копируем туда значения из предыдущего обновленного массива
					int v[N];
					for (int i = 0; i < n; i++)
						v[i] = vershini[i];
					// Рекурсивный вызов на новую вершину
					Recursion(nomer_ish, j, kol, sum + MASS[nomer][j], v);
					continue;
				}
				else
				{
					// Если мы в ней уже были - она в цикл уже вошла и на неё переходить не нужно
					continue;
				}
			}
		}
	}
}

int main()
{
	// ВАЖНО: в программировании счет идет от 0(нуля), т.е. если количество равно 4, то в "реальной жизни" оно равно 4+1 = 5
	// Считаем, что граф неориентированный: т.е. по дорогам можно идти в обе стороны

	setlocale(LC_ALL, "Russian");// Для чтения русского языка
	// Заполняем матрицу смежности из файла:
	// номер вершин в графе: нумеруются с нуля: 0, 1, 2, 3, .., n
	ifstream f("graf.txt");
	// Считаем переменные из файла:
	f >> n;// Количество точек графа
	f >> m;// Количество строк описания в текстовом файле(переходы-ребра)
	
	for (int i = 0; i < m; i++)
	{
		// Считаем
		int v1=0;
		f >> v1;
		int v2=0;
		f >> v2;
		int l;
		f >> l;

		// Отметим в матрице смежности
		MASS[v1][v2] = l;
		MASS[v2][v1] = l;
	}
	f.close();

	// Вызываем рекурсивную функцию печати всех возможных путей:
	// передаём ей:
	// nomer_ish - номер исходной вершины, в которую должен вернуться цикл
	// nomer - просто номер вершины, на которой цикл сейчас находится.
	// kol - количество посещенных вершин графа(в которых цикл побывал) = 0
	// sum - сумма путей(изначально равно 0)
	// versini -  массив непосещенных вершин
	// n - количество вершин в графе(размерность матрицы смежности)
	for (int i = 0; i < n; i++)
	{
		int vershini[N];// Создали массив вершин
		// пусть значение -1 - значит, что мы эту вершину не посетили, а если посетили, то по порядку: 0, 1, 2, 3 и т.д. вершины
		// например: -1 0 -1 1 -1 3 -1 2 -1 4 - всего 10 элементов(от 0 до 9 счет), а посетили мы по порядку только первую(т.к. счет от нуля), третью, пятую, седьмую и девятую вершину
		for (int i = 0; i < n; i++)
		{
			vershini[i] = -1;
		}

		// Запустим рекурсивную функцию поиска путей
		Recursion(i, i, 0, 0, vershini);// nomer = i - это вершина(всего в графе n вершин)
	}

	_getch();// Чтобы консоль не закрывалась
}