using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace EpsilonMethod
{
    // Вспомогательный класС, для хранения пар координат: икс и игрек
    class Pair
    {
        public int I, J;

        public Pair(int _i, int _j)
        {
            I = _i;
            J = _j;
        }
    }

    class Transport
    {
        // Конструктор
        public Transport(ref RichTextBox rTB, double[,] стоимости, double[] потребители, double[] поставщики)
        {
            окно = rTB;

            // Очистим окно
            окно.Clear();
            // Инициализируем переменный
            Стоимости = стоимости;
            Потребители = потребители;
            Поставщики = поставщики;
            КонечнаяСумма = 0;
            КоличествоПоставщиков = Поставщики.Length;
            КоличествоПотребителей = Потребители.Length;
            NVeryLargeNumber = 99999999999;
            nomer = 0;
            // Т.к. это эпсилон метод - добавим небольшие величины к поставщикам и потребителям
            var эпсилон = 0.001;
            for (int i = 0; i < КоличествоПотребителей; i++)
            {
                Потребители[i] += (double)эпсилон / Потребители.Length;
            }

            окно.Text += '\n' + "Эпсилон: " + эпсилон;
            Поставщики[1] += (double)эпсилон;

            МатрицаПоискаОптимальногоПлана = new double[КоличествоПоставщиков, КоличествоПотребителей];
            for (int i = 0; i < КоличествоПоставщиков; i++)
            {
                for (int j = 0; j < КоличествоПотребителей; j++)
                {
                    МатрицаПоискаОптимальногоПлана[i, j] = 0;
                }
            }

            ДвойственнаяМатрица = new double[КоличествоПоставщиков, КоличествоПотребителей];
            for (int i = 0; i < КоличествоПоставщиков; i++)
            {
                for (int j = 0; j < КоличествоПотребителей; j++)
                {
                    ДвойственнаяМатрица[i, j] = -1;
                }
            }

            // Начинаем решение с запуска метода сев-западного угла
            МетодСевероЗападногоУгла();

            X_КоординатаОпорнойТочки = -1;
            Y_КоординатаОпорнойТочки = -1;

            ПечатьШага();
        }

        private int nomer = 0;
        // richTextBox, в который будем процесс выводить
        private RichTextBox окно;
        // Стоимости
        public  double[,] Стоимости;
        // потребители
        public  double[] Потребители;
        // поставщики
        public  double[] Поставщики;
        // Конечная сумма
        public double КонечнаяСумма;

        // Вспомогательная матрица: двойственная
        public  double[,] ДвойственнаяМатрица;
        public  double[,] МатрицаПоискаОптимальногоПлана;

        // Координаты опорной точки
        public  int КоличествоПоставщиков, КоличествоПотребителей;
        public  int X_КоординатаОпорнойТочки;
        public  int Y_КоординатаОпорнойТочки;

        // Просто очень большое число для сравнения
        public  double NVeryLargeNumber;

        // Северо-западный метод
        public void МетодСевероЗападногоУгла()
        {
            var u = 0;
            var v = 0;

            double[] aS = new double[КоличествоПотребителей];
            double[] aD = new double[КоличествоПоставщиков];

            // Ну, тут уже ясно - "зигзамом" идем по матрице и ищем точки
            while (u <= КоличествоПоставщиков - 1 && v <= КоличествоПотребителей - 1)
            {
                if (Потребители[v] - aS[v] < Поставщики[u] - aD[u])
                {
                    var z = Потребители[v] - aS[v];
                    МатрицаПоискаОптимальногоПлана[u, v] = z;
                    aS[v] += z;
                    aD[u] += z;
                    v += 1;
                }
                else
                {
                    var z = Поставщики[u] - aD[u];
                    МатрицаПоискаОптимальногоПлана[u, v] = z;
                    aS[v] += z;
                    aD[u] += z;
                    u += 1;
                }
            }
        }

        // Есть ли положительные точки(не удовлетворяют условию оптимальности)?
        public bool ПроверкаНаОптимальность()
        {
            double nMax = -99999999999;//NVeryLargeNumber;
            ПолучитьДвойственную();
            for (var i = 0; i < КоличествоПоставщиков; i++)
            {
                for (var j = 0; j < КоличествоПотребителей; j++)
                {
                    var x = ДвойственнаяМатрица[i, j];
                    if (x > nMax)
                    {
                        nMax = x;
                        X_КоординатаОпорнойТочки = i;
                        Y_КоординатаОпорнойТочки = j;
                    }
                }
            }
            return (nMax > 0);
        }

        // Вывод результатов:
        public void ПечатьШага()
        {
            ПолучитьДвойственную();
            double nCost = 0;

            окно.Text += "\nШаг №" + (nomer++);

            for (int i = 0; i < КоличествоПоставщиков; i++)
            {
                for (int j = 0; j < КоличествоПотребителей; j++)
                {
                    nCost += Стоимости[i, j] * МатрицаПоискаОптимальногоПлана[i, j];
                    if (МатрицаПоискаОптимальногоПлана[i, j].Equals(0))
                    {
                        окно.Text+='\n'+ String.Format("[<{0}>,{1}]", Стоимости[i, j], ДвойственнаяМатрица[i, j]);
                    }
                    else
                    {
                        окно.Text+='\n'+ String.Format("[<{0}>,({1})]", Стоимости[i, j], ДвойственнаяМатрица[i, j] + 0.5);
                    }
                }
                окно.Text+='\n'+String.Format(" : {0}", Поставщики[i]);
            }
            окно.Text += "\nПолучилась матрица:\n";

            for (int i = 0; i < КоличествоПоставщиков; i++)
            {
                for (int j = 0; j < КоличествоПотребителей; j++)
                {
                    окно.Text += String.Format("{0}  ", МатрицаПоискаОптимальногоПлана[i, j]);
                }
                окно.Text += '\n';
            }

            окно.Text+='\n'+("Стоимость: " + nCost);
            КонечнаяСумма = nCost;
        }


        public void ПолучитьДвойственную()
        {
            for (int i = 0; i < КоличествоПоставщиков; i++)
            {
                for (int j = 0; j < КоличествоПотребителей; j++)
                {
                    ДвойственнаяМатрица[i, j] = (double)-0.5; // null value
                    if (МатрицаПоискаОптимальногоПлана[i, j].Equals(0))
                    {
                        List<Pair> aPath = НайтиПутьЦикл(i, j);
                        double z = -1;
                        double x = 0;
                        foreach (var pair in aPath)
                        {
                            x += z * Стоимости[pair.I, pair.J];
                            z *= -1;
                        }
                        ДвойственнаяМатрица[i, j] = x;
                    }
                }
            }
        }

        public List<Pair> НайтиПутьЦикл(int i, int j)
        {
            var aPath = new List<Pair>();
            aPath.Add(new Pair(i, j));
            if (!ИскатьПоГоризонтали(ref aPath, i, j, i, j))
            {
                окно.Text+='\n'+("Произошла ошибка на позиции:[" + i.ToString() +";"+ j.ToString()+"]");
            }

            return aPath;
        }

        public bool ИскатьПоГоризонтали(ref List<Pair> aPath, int u, int v, int u1, int v1)
        {
            for (int i = 0; i < КоличествоПотребителей; i++)
            {
                if (i != v && !МатрицаПоискаОптимальногоПлана[u, i].Equals(0))
                {
                    if (i == v1)
                    {
                        aPath.Add(new Pair(u, i));
                        return true;
                    }
                    if (ИскатьПоВертикали(ref aPath, u, i, u1, v1))
                    {
                        aPath.Add(new Pair(u, i));

                        return true;
                    }
                }
            }
            return false;
        }

        private bool ИскатьПоВертикали(ref List<Pair> aPath, int u, int v, int u1, int v1)
        {
            for (int i = 0; i < КоличествоПоставщиков; i++)
            {
                if (i != u && !МатрицаПоискаОптимальногоПлана[i, v].Equals(0))
                {
                    if (ИскатьПоГоризонтали(ref aPath, i, v, u1, v1))
                    {
                        aPath.Add(new Pair(i, v));//[i, v]);
                        return true;
                    }
                }
            }
            return false;
        }

        public void СделатьОптимальным()
        {
            var aPath = НайтиПутьЦикл(X_КоординатаОпорнойТочки, Y_КоординатаОпорнойТочки);

            double nMin = NVeryLargeNumber;

            for (int i = 1; i < aPath.Count; i = i + 2)
            {
                var t = МатрицаПоискаОптимальногоПлана[aPath[i].I, aPath[i].J];
                if (t < nMin)
                    nMin = t;
            }
            for (int i = 1; i < aPath.Count; i = i + 2)
            {
                МатрицаПоискаОптимальногоПлана[aPath[i].I, aPath[i].J] -= nMin;
                МатрицаПоискаОптимальногоПлана[aPath[i - 1].I, aPath[i - 1].J] += nMin;
            }
        }

        public void НачатьРешение()
        {
            
            // Обработка
            while (ПроверкаНаОптимальность())
            {
                окно.Text+='\n'+("Опорная точка: [" + X_КоординатаОпорнойТочки.ToString() +";"+ Y_КоординатаОпорнойТочки.ToString()+"]");
                СделатьОптимальным();
                ПечатьШага();
            }

            окно.Text+='\n'+"КОНЕЦ" +'\n';
        }
    }
}
