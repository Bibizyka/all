using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BulatSal
{
    class Program
    {
        //Алгоритм, генетический. Получаем массив двумерный с данными
        //Итог алгоритма - выбор наиболее оптимального значения - длины выполнения S
        //S - время выполнения
        //P - время простоя
        //N - количество строк
        //M - количество столбцов
        //mass - собственно наш массив
        public static int Search(int[,] mass, int N, int M)//Поиск в заданном массиве минимального Времени выполнения и Времени простоя
        {
            //Получаем массив по всем вызовам комбинаций
            //Передаем: 0 - элемент, от которого считаем, 
            //N-число, до которого считаем
            //x-массив для записи элементов
            //0 - index для заполнения massiv
            //massiv - массив для получения элементов
            int[] x = new int[100000];
            int[,] massiv = new int[100000, N];
            int index = 0;
            int[,] perestanovki = NumbersOfPerestanovok(0, N, x, ref index, massiv);

            //Теперь - каждый раз получая из нашего массива проектов НОВЫЙ массив с перестановками строк по полученной комбинации - ищем оптимальное время выполнения.
            //Реализуем поиск времени выполнения работы и времени простоя
            //Ищем первый элемент для сравнения        
            int S = 0;
            int P = 0;
            int index_comb=0;//Индекс комбинации
                for (int i = 0; i < M * 2 - 1; i++)
                {
                    int temp = MaxElementsInDiag(mass, i, N, M);
                    S = S + temp;
                    P = P + DifBetweenElementsInDiag(mass, i,N, M, temp);
                }
                //Console.Write("S= "+S);//
                //Console.WriteLine(" P= " + P);//
                //PrintCombination(perestanovki, 0, N);//
                //Console.WriteLine();//

            //Т.к. W=0 проходку сделали, начинаем с W=1;
            for (int W = 1; W < index; W++)
            {
                int[,] new_mass=new int[N,M];
                //Передаем исходный массив проектов, его параметры - число СТРОК и СТОЛБЦОВ, комбинацию перестановок по индексу и Индекс(номер по порядку перестановки)/
                new_mass = PerestanovkaColumns(mass, N, M, perestanovki,W);

                int S_new = 0;
                int P_new = 0;
                for (int i = 0; i < M * 2 - 1; i++)
                {
                    int temp = MaxElementsInDiag(new_mass, i, N, M);
                    S_new = S_new + temp;
                    P_new = P_new + DifBetweenElementsInDiag(new_mass, i, N, M, temp);
                }
                //Console.Write("S= "+S_new);//
                //Console.WriteLine(" P= " + P_new);//
                //PrintCombination(perestanovki, W, N);//
                //Console.WriteLine();//

                //Ищем минимальное время выполнения
                if (S_new < S)
                {
                    S = S_new; P = P_new; index_comb = W;
                }
            }
            //Console.WriteLine("Rezult: S=" + S + ", P=" + P);//
            //PrintCombination(perestanovki, index_comb, N);//
            return S;
        }

        //Печать комбинации
        public static void PrintCombination(int[,] perestanovki, int w, int N)
        {
            for (int i = 0; i < N; i++)
                Console.Write(perestanovki[w,i]+" ");
            Console.WriteLine();
        }

        //Формирование нового массива по коду перестановок
        public static int[,] PerestanovkaColumns(int[,] mass, int N, int M, int[,] perestanovki, int W)
        {
            int[,] new_mass= new int[N,M];

            //Идем по строкам
            for(int i=0; i<N; i++)
            {
                //Копируем каждую строку
                for(int j=0; j<M; j++)
                {
                    new_mass[i,j]=mass[perestanovki[W,i]-1,j];
                }

            }

            return new_mass;
        }

        //Передаем массив, номер диагонали и длину стороны квадрата
        //Находим сумму элементов в диагонали
        public static int SumElementsInDiag(int[,] mass, int i, int N, int M)
        {
            int SUM = 0;
            if (i < N)
                for (int x = i, y = 0; x >= 0 && y<M; x--, y++)
                {
                    SUM = SUM + mass[x, y];
                }
            else
                for (int x = N-1, y = i-N+1; y < N && y<M; x--, y++)
                {
                    SUM = SUM + mass[x, y];
                }
            
            return SUM;
        }

        //Поиск максимального элемента в диагонали
        public static int MaxElementsInDiag(int[,] mass, int i, int N, int M)
        {   
            int MAX = 0;
            if (i < N)
                for (int x = i, y = 0; x >= 0 && y<M; x--, y++)
                {
                    if (mass[x, y] > MAX) MAX = mass[x, y];
                }
            else
                for (int x = N - 1, y = i - N + 1; y < M && x >= 0; x--, y++)
                {
                    if (mass[x, y] > MAX) MAX = mass[x, y];
                }

            return MAX;
        }

        //Находим разницу между элементами в диагонали - это и есть время простоя
        public static int DifBetweenElementsInDiag(int[,] mass, int i, int N, int M, int temp)
        {
            int P = 0;
            if (i < N)
                for (int x = i, y = 0; x >= 0 && y < M; x--, y++)
                {
                    P = P+ (temp-mass[x, y]);
                }
            else
                for (int x = N - 1, y = i - N + 1; y < M && x >= 0; x--, y++)
                {
                    P = P + (temp - mass[x, y]);
                }

            return P;
        }

        //Рекурсивная функция получения комбинаций вызовов
        //Передается число, от которого отсчитывать и число, к которму считать перестановку, например [от 3, до 9]
        //x - массив, в который записываются различные комбинации
        public static int[,] NumbersOfPerestanovok(int k, int n, int[] x,ref int index, int[,] mass)
        {
            if (k == n)
            {
                int schet = 0; //Переменнная, которая подсчитывает количество НЕповторений всех элементов в ряду перестановки.
                int poz = 0;//Переменная, для сравнения с вышеназванной schet. 

                for (int t = 1; t < n; t++)//Подсчитывает все числа от 1 до N - количество именно сравнений на повторяемость элементов. В принципе, можно было вывести цикл
                    //вне процедуры ради экономии времени подсчета, работы рекурсии. Но пришлось бы вводить новые переменные для передачи в процедуру.
                    poz = poz + t;

                for (int w = 0; w < n; w++)//Элементарный цикл подсчета НЕповторяемости элементов в перестановке(массиве)
                    for (int y = w + 1; y < n; y++)
                    {
                        if (x[w] != x[y]) schet++;
                    }

                if (schet == poz)//В зависимости от равенства переменных происходит печать подстановки. 
                //В результате печатаются подстановки, в которых отсутствует повторяемость элементов.
                {
                    for (int i = 0; i < n; i++)
                    {
                        mass[index, i] = x[i];
                    }
                    index++;
                }
                
            }
            else
            {
                for (int r = 0; r < n; r++)
                {
                    x[k] = r + 1;
                    NumbersOfPerestanovok(k + 1, n, x, ref index, mass);
                }
            }
            return mass;
        }

        static void Main(string[] args)
        {
            const int  N=7, M=5;//N-количество строк, M-столбцов
            int[,] mass = new int[N,M] 
            {
                {3, 4, 2, 3, 5},
                {2, 3, 1, 4, 4},
                {2, 2, 1, 5, 4},
                {1, 3, 2, 3, 3},
                {2, 4, 4, 2, 4},
                {3, 3, 5, 1, 4},
                {1, 3, 3, 3, 5},
            };

 
            Console.WriteLine(Search(mass, N, M));

            Console.ReadKey();
        }
    }
}
