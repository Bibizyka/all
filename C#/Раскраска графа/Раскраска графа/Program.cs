using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

/*
 * Aлгоритм приближенной раскраски:
1. Вычислить степени вершин. Положить K=1.Пример.
2. Просмотреть вершины в порядке не возрастания степеней и окрасить первую неокрашенную вершину в цвет № K.
3. Просмотреть вершины в порядке не возрастания степеней и окрасить в цвет №К все вершины, которые не смежны вершинам, уже окрашенным в цвет №К.
4. Если все вершины окрашены, то К-искомое хроматическое число. Пример.Иначе К=К+1 и переход к пункту 2.
*/


namespace Раскраска_графа
{
    class Program
    {
        //Структура графа
        public struct Graf
        {
            public int stepeni;//Степень
            public int color;//"Цвет" - цифра
            public int number;//Номер
        };

        //Инициализируем все цвета цифрой 100 - для "красоты", т.к. граф из 100 вершин вряд ли будет рассматриваться
        public static void ЗаполнитьГраф(Graf[] mass, int n)
        {
            for (int s = 0; s < n; s++)
            {
                mass[s].color = 100;
            }
        }

        //Выводит результат
        public static void ПечатьГрафа(Graf[] mass)
        {
            for (int s = 0; s < mass.Length; s++)
            {
                //Выводит - вершина и её цвет
                Console.WriteLine(mass[s].number + " -- " + mass[s].color);
            }
        }

        //Возвращает ноль, если все цвета уже присвоены
        public static bool НеВсёЗакрашено(Graf[] mass)
        {
            int flag = 0;
            for (int x = 0; x < mass.Length; x++) //Цикл проверяет - все ли цвета посещены
            {
                if (mass[x].color <= mass.Length)
                    flag++;
            }

            if (flag == mass.Length)
                return false;
            else
                return true;
        }

        static void Main(string[] args)
        {
            const int n = 4;// Количество вершин в графе
            int versh = 0;

            //Для таблицы смежности 4 на 4 = >Максимальное число цветов равно количеству вершин	
            int[] colors = { 1, 2, 3, 4 };// 

            // Создадим графф
            Graf[] graf = new Graf[n];//Граф
            
            //Матрица смежности
            int[,] m = new int[n, n]{{0, 1, 1, 0},
				                     {1, 0, 1, 0},
				                     {1, 1, 0, 1},
				                     {0, 0, 1, 0}};
            

            ЗаполнитьГраф(graf, n);//Забиваем все цвета по умолчанию - 100

            //Находим степени вершин по матрице смежности
            for (int i = 0; i < n; i++, versh++)
            {
                graf[versh].stepeni = 0;
                graf[versh].number = i;

                for (int j = 0; j < n; j++)
                {
                    if (m[i, j] == 1)
                        graf[versh].stepeni++;
                }
            }

            //Сортировка структуры графа по степеням с наибольшей по наименьшую
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                {
                    if (graf[i].stepeni > graf[j].stepeni)
                    {
                        Graf temp = graf[i];
                        graf[i] = graf[j];
                        graf[j] = temp;
                    }
                }

            //Алгоритм по присвоению цветов 
            int t = 0, flag, metka = 0;

            for (int x = 0; НеВсёЗакрашено(graf); x++)//Цикл по цветам. Условие выхода - все цвета окрашены! Пока не раскрашено( НеВсёЗакрашено) - работает
            {
                if (graf[x].color == 100)
                    graf[x].color = colors[x];//Присваиваем первый цвет

                // продолжаем дальше;
                for (int i = 0; i < n; i++)//цикл, чтобы не только одни вершины раскрасить, а ВСЕ НЕ смежные
                {
                    t = graf[i].number;//Запоминаем номер исследуемой вершины
                    flag = 0;//Обнуляем Флаг - считает количество вершин, не раскрашенных как исследуемая
                    for (int j = 0; j < n; j++)//Идем по строке матрицы по номеру
                    {
                        //Блок условий проверки на возможность "раскраски" вершины. Под раскраской - подразумевается присваивание номера
                        if ((m[t, j] == 1 && t != j))//Если 1 - можно перейти на какое-то ребро и это ребро - не та же самая вершина(которая рассматривается
                        {
                            for (int s = 0; s < n; s++)
                                if (j == graf[s].number && graf[s].color != colors[x])
                                {
                                    flag++;
                                }
                        };

                        if (graf[j].number == t)
                            metka = j;

                        if (flag == graf[metka].stepeni && graf[metka].color == 100)//Если вершина ещё не посещена - забиваем в неё определенный цвет из массива цветов
                            graf[metka].color = colors[x];
                    }
                }
            }

            Console.WriteLine("Результат раскраски - второй столбик. Первый столбик - номер вершины");

            //Показываем результат
            ПечатьГрафа(graf);

            Console.ReadKey();
        }
    }
}
